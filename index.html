<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL Pinger</title>
    <!-- PWA Links -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#e0e5ec"> <!-- Updated theme color -->
    <!-- End PWA Links -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Neumorphic Styles inspired by the image */
        :root {
            --neumorphic-bg: #e0e5ec; /* Light gray/blue base */
            --neumorphic-text-primary: #374151; /* gray-700 */
            --neumorphic-text-secondary: #6b7280; /* gray-500 */
            --neumorphic-text-placeholder: #9ca3af; /* gray-400 */
            --neumorphic-shadow-light: #ffffff;
            --neumorphic-shadow-dark: #a3b1c6;
            --neumorphic-accent: #3b82f6; /* blue-500 for subtle accents */
            --neumorphic-error: #ef4444; /* red-500 */
            --neumorphic-success: #22c55e; /* green-500 */
        }

        body {
            background-color: var(--neumorphic-bg);
            font-family: 'Inter', sans-serif; /* Using Inter font for a clean look */
            min-height: 100vh;
            color: var(--neumorphic-text-primary);
        }

        /* Add Inter font from Google Fonts (Optional but recommended for look) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        /* Neumorphic Outer Shadow (Extruded) */
        .neumorphic-shadow-outer {
            box-shadow: 6px 6px 12px var(--neumorphic-shadow-dark), -6px -6px 12px var(--neumorphic-shadow-light);
        }
        .neumorphic-shadow-outer-sm {
            box-shadow: 3px 3px 6px var(--neumorphic-shadow-dark), -3px -3px 6px var(--neumorphic-shadow-light);
        }

        /* Neumorphic Inner Shadow (Pressed) */
        .neumorphic-shadow-inner {
            box-shadow: inset 6px 6px 12px var(--neumorphic-shadow-dark), inset -6px -6px 12px var(--neumorphic-shadow-light);
        }
        .neumorphic-shadow-inner-sm {
             box-shadow: inset 3px 3px 6px var(--neumorphic-shadow-dark), inset -3px -3px 6px var(--neumorphic-shadow-light);
        }

        /* Button Active State (Pressed Down) */
        .neumorphic-button:active {
            box-shadow: inset 4px 4px 8px var(--neumorphic-shadow-dark), inset -4px -4px 8px var(--neumorphic-shadow-light);
            color: var(--neumorphic-accent); /* Example: Accent color on press */
        }

        /* Input Field Styling */
        .neumorphic-input {
            background-color: var(--neumorphic-bg);
            border: none;
            outline: none;
            color: var(--neumorphic-text-primary);
            padding: 0.75rem 1rem; /* 12px 16px */
            border-radius: 0.5rem; /* 8px */
        }
        .neumorphic-input::placeholder {
            color: var(--neumorphic-text-placeholder);
        }
        .neumorphic-input:focus {
             /* Optional: subtle outer glow on focus, or keep it pressed */
             /* box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); */
        }


        /* Status Dot & Loader */
        .status-dot {
            width: 0.875rem; /* 14px */
            height: 0.875rem; /* 14px */
            border-radius: 50%;
            display: inline-block;
            flex-shrink: 0;
            margin-top: 3px; /* Adjust alignment */
             /* Add subtle shadow to dots */
             box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .status-ok { background-color: var(--neumorphic-success); }
        .status-error { background-color: var(--neumorphic-error); }
        .status-pending { background-color: #9ca3af; } /* gray-400 */
        .status-checking { background-color: var(--neumorphic-accent); }

        .loader {
            border: 3px solid rgba(163, 177, 198, 0.3); /* Lighter border based on dark shadow */
            border-top: 3px solid var(--neumorphic-accent);
            border-radius: 50%;
            width: 14px;
            height: 14px;
            animation: spin 1s linear infinite;
            display: inline-block;
            flex-shrink: 0;
            margin-top: 3px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* History Bar Styles */
        .history-bar {
            display: flex;
            height: 10px; /* Slightly smaller height */
            overflow: hidden;
            flex-direction: row-reverse; /* Keeps newest left */
            width: 100%;
            margin-top: 8px;
            border-radius: 3px; /* Rounded corners */
             /* Give it a slightly inset look */
             background-color: #cbd5e1; /* Slightly darker than base bg */
             box-shadow: inset 1px 1px 2px var(--neumorphic-shadow-dark), inset -1px -1px 2px var(--neumorphic-shadow-light);
        }
        .history-point {
            width: 3px;
            height: 100%;
            margin-right: 1px;
            flex-shrink: 0;
            flex-grow: 0;
             /* Remove rounding from individual points if bar is rounded */
             border-radius: 0;
        }
        .history-bar .history-point:first-child {
            margin-right: 0;
        }
        .history-ok { background-color: var(--neumorphic-success); }
        .history-error { background-color: var(--neumorphic-error); }

        /* Custom Scrollbar */
        #urlList {
            max-height: calc(100vh - 350px); /* Adjust based on other elements */
            overflow-y: auto;
            padding-right: 5px; /* Space for scrollbar */
        }
        #urlList::-webkit-scrollbar {
            width: 8px;
        }
        #urlList::-webkit-scrollbar-track {
            background: transparent; /* Track blends with background */
        }
        #urlList::-webkit-scrollbar-thumb {
            background: var(--neumorphic-shadow-dark); /* Use dark shadow color */
            border-radius: 4px;
        }
        #urlList::-webkit-scrollbar-thumb:hover {
            background: var(--neumorphic-text-secondary); /* Slightly darker on hover */
        }

    </style>
</head>
<body class="pt-8 pb-8 px-4">

    <div id="app" class="max-w-md mx-auto bg-[var(--neumorphic-bg)] rounded-2xl neumorphic-shadow-outer p-6 sm:p-8">
        <div class="flex justify-between items-center mb-8">
             <h1 class="text-xl font-semibold text-[var(--neumorphic-text-primary)]">URL Pinger</h1>
             <!-- Placeholder for settings icon like in image -->
             <button class="w-8 h-8 flex items-center justify-center rounded-full neumorphic-shadow-outer-sm neumorphic-button text-[var(--neumorphic-text-secondary)] hover:text-[var(--neumorphic-accent)] transition-colors">
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                   <path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527c.43-.308.98-.286 1.37.058l.772.68c.398.349.44.964.103 1.36l-.737.893c-.347.424-.434.987-.23 1.45l.414.963c.218.507.127 1.09-.232 1.49l-.793.854c-.34.368-.83.553-1.317.553h-1.05c-.474 0-.92-.213-1.22-.581l-.632-.74c-.31-.363-.79-.574-1.27-.525-.48.05-.91.346-1.14.769l-.317.941a1.186 1.186 0 0 1-1.11.941h-1.094c-.55 0-1.01-.398-1.1-.94l-.15-.894a1.186 1.186 0 0 0-.78-.93c-.398-.164-.854-.142-1.204.108l-.738.527c-.43.308-.98.286-1.37-.058l-.772-.68c-.398-.349-.44-.964-.104-1.36l.738-.893c.346-.424.434-.987.23-1.45l-.415-.963a1.43 1.43 0 0 1 .232-1.49l.793-.854c.34-.368.83-.553 1.317-.553h1.05c.473 0 .92.213 1.22.581l.632.74c.31.363.79.574 1.27.525.48-.049.91-.345 1.14-.769l.317-.941ZM12 15.75a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Z" />
                 </svg>
             </button>
        </div>


        <div class="mb-6">
            <!-- Removed label, using placeholder -->
            <div class="flex space-x-3 items-center">
                 <input type="url" id="urlInput" placeholder="Add URL: https://example.com" class="flex-grow neumorphic-input neumorphic-shadow-inner" required>
                <button id="addUrlBtn" class="neumorphic-shadow-outer-sm neumorphic-button bg-[var(--neumorphic-bg)] text-[var(--neumorphic-text-secondary)] hover:text-[var(--neumorphic-accent)] font-medium py-2 px-4 rounded-lg transition-all duration-150 ease-in-out h-[44px] flex-shrink-0">
                    Add
                </button>
            </div>
            <p id="errorMsg" class="text-[var(--neumorphic-error)] text-sm mt-2 h-4 pl-1"></p> <!-- Error message area -->
        </div>

        <div class="mt-8">
            <h2 class="text-lg font-medium text-[var(--neumorphic-text-primary)] mb-4">Monitored URLs</h2>
            <div id="urlList" class="space-y-4">
                <!-- URL items will be injected here -->
                 <p class="text-[var(--neumorphic-text-secondary)] italic">No URLs added yet.</p>
            </div>
        </div>
    </div>

    <script>
        const urlInput = document.getElementById('urlInput');
        const addUrlBtn = document.getElementById('addUrlBtn');
        const urlList = document.getElementById('urlList');
        const errorMsg = document.getElementById('errorMsg');

        // { id: number, url: string, status: 'pending'|'ok'|'error'|'checking', ip: string, responseTime: number|null, lastChecked: string|null, intervalId: number|null, isChecking: boolean, history: Array<{timestamp: number, status: 'ok'|'error'}> }
        let monitoredUrls = [];
        let nextId = 0;

        const PING_INTERVAL_MS = 1* 1000; // 1 minute (Adjusted for clarity)
        const HISTORY_DURATION_MS = 60 * 60 * 1000; // 60 minutes
        const MAX_HISTORY_POINTS = 90; // Number of points to show visually (~60 min / 40 sec per point) - adjusted based on bar size/looks

        // --- Local Storage ---
        function loadUrlsFromStorage() {
            const storedUrls = localStorage.getItem('monitoredUrls');
            if (storedUrls) {
                const loadedData = JSON.parse(storedUrls);
                nextId = loadedData.reduce((maxId, url) => Math.max(maxId, url.id || -1), -1) + 1;
                monitoredUrls = loadedData.map(url => ({
                    ...url,
                    id: url.id !== undefined ? url.id : nextId++,
                    status: 'pending',
                    ip: url.ip || 'N/A',
                    responseTime: null,
                    lastChecked: null,
                    intervalId: null,
                    isChecking: false,
                    history: [] // History is not stored
                }));
                renderUrlList();
                startAllChecks();
            }
        }

        function saveUrlsToStorage() {
            const urlsToSave = monitoredUrls.map(({ intervalId, isChecking, history, ...rest }) => rest);
            localStorage.setItem('monitoredUrls', JSON.stringify(urlsToSave));
        }


        // --- IP Address Lookup ---
        async function getIpAddress(hostname) {
             try {
                 if (!hostname || /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.test(hostname)) {
                     return hostname || 'N/A';
                 }
                const response = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(hostname)}&type=A`, {
                    headers: { 'accept': 'application/dns-json' },
                    signal: AbortSignal.timeout(5000)
                });
                if (!response.ok) {
                    console.warn(`DNS query failed for ${hostname}: Status ${response.status}`);
                    return 'N/A';
                }
                const data = await response.json();
                if (data.Answer && data.Answer.length > 0) {
                    const aRecord = data.Answer.find(ans => ans.type === 1);
                    return aRecord ? aRecord.data : 'N/A';
                }
                console.warn(`No A record found for ${hostname}`);
                return 'N/A';
            } catch (error) {
                console.error(`Error fetching IP for ${hostname}:`, error);
                 if (/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.test(hostname)) {
                     return hostname;
                 }
                return 'N/A';
            }
        }

        // --- URL Checking Logic ---
         function pruneHistory(urlData) {
            const cutoff = Date.now() - HISTORY_DURATION_MS;
            urlData.history = urlData.history.filter(entry => entry.timestamp >= cutoff);
        }

        async function checkUrlStatus(urlData) {
            if (urlData.isChecking) {
                // console.log(`Skipping check for ${urlData.url}: Already checking.`);
                return;
            }

            // console.log(`Checking ${urlData.url}...`);
            urlData.isChecking = true;
            urlData.status = 'checking';
            renderUrlList(); // Update UI immediately

            const startTime = performance.now();
            let checkStatus = 'error';
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                // console.warn(`Check timed out for ${urlData.url}`);
                 controller.abort('Timeout');
            }, 15000);

            try {
                 await fetch(urlData.url, { method: 'HEAD', mode: 'no-cors', signal: controller.signal });
                 checkStatus = 'ok';
            } catch (headError) {
                 // console.warn(`HEAD failed for ${urlData.url} (${headError.name || headError.message}). Trying GET...`);
                 try {
                     await fetch(urlData.url, { method: 'GET', mode: 'no-cors', signal: controller.signal });
                     checkStatus = 'ok';
                 } catch (getError) {
                     // console.warn(`GET also failed for ${urlData.url} (${getError.name || getError.message}). Marking as error.`);
                     checkStatus = 'error';
                 }
            } finally {
                clearTimeout(timeoutId);

                urlData.responseTime = null;
                 if(checkStatus === 'ok') {
                    urlData.responseTime = Math.round(performance.now() - startTime);
                 }

                 urlData.status = checkStatus;
                 urlData.lastChecked = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // Shorter time format
                 urlData.isChecking = false;

                 urlData.history.push({ timestamp: Date.now(), status: checkStatus });
                 pruneHistory(urlData);

                 renderUrlList(); // Update UI with final status
                 // Save periodically or on specific events if needed, not saving after every check here.
            }
        }

        // --- Uptime Calculation ---
        function calculateUptimeAndHistoryPoints(history) {
            const cutoff = Date.now() - HISTORY_DURATION_MS;
            const relevantHistory = history.filter(entry => entry.timestamp >= cutoff);

            if (relevantHistory.length === 0) {
                return { percentage: '--%', points: [] }; // Use '--%' for N/A
            }

            const okCount = relevantHistory.filter(entry => entry.status === 'ok').length;
            const percentage = Math.round((okCount / relevantHistory.length) * 100);

            // Prepare history points (limit to MAX_HISTORY_POINTS visually)
            const points = relevantHistory
                .slice(-MAX_HISTORY_POINTS)
                .map(entry => entry.status);

            return { percentage: `${percentage}%`, points: points };
        }


        // --- UI Rendering ---
        function renderUrlList() {
            const listContainer = document.getElementById('urlList'); // Target the container
            listContainer.innerHTML = ''; // Clear existing list

            if (monitoredUrls.length === 0) {
                 listContainer.innerHTML = '<p class="text-[var(--neumorphic-text-secondary)] italic px-2">No URLs added yet.</p>';
                return;
            }

            monitoredUrls.forEach(urlData => {
                const item = document.createElement('div');
                 // Neumorphic card style for each item
                 item.className = 'bg-[var(--neumorphic-bg)] rounded-xl neumorphic-shadow-outer-sm p-4';
                item.dataset.id = urlData.id;

                let statusIndicatorHtml;
                if (urlData.isChecking) {
                    statusIndicatorHtml = '<span class="loader" title="Checking..."></span>';
                } else {
                    const statusClass = urlData.status === 'ok' ? 'status-ok' : (urlData.status === 'error' ? 'status-error' : 'status-pending');
                    const statusTitle = urlData.status === 'ok' ? 'Reachable' : (urlData.status === 'error' ? 'Error/Unreachable' : 'Pending Check');
                    statusIndicatorHtml = `<span class="status-dot ${statusClass}" title="${statusTitle}"></span>`;
                }

                 const responseTimeText = urlData.responseTime !== null ? `${urlData.responseTime} ms` : '--';
                 const lastCheckedText = urlData.lastChecked ? `Last check: ${urlData.lastChecked}` : 'Not checked';
                const { percentage: uptimePercentage, points: historyPoints } = calculateUptimeAndHistoryPoints(urlData.history);

                // Generate History Bar HTML
                 let historyBarHtml = `<div class="history-bar" title="History (Newest left, Oldest right)">`;
                 historyPoints.slice().reverse().forEach(status => { // reverse needed because flex-direction is row-reverse
                    const historyClass = status === 'ok' ? 'history-ok' : 'history-error';
                    historyBarHtml += `<div class="history-point ${historyClass}"></div>`;
                });
                 historyBarHtml += '</div>';


                item.innerHTML = `
                    <div class="flex items-start justify-between space-x-3">
                        <div class="flex items-start space-x-3 flex-grow min-w-0">
                            ${statusIndicatorHtml}
                            <div class="min-w-0">
                                <p class="text-[var(--neumorphic-text-primary)] font-medium truncate text-sm" title="${urlData.url}">${urlData.url}</p>
                                <p class="text-xs text-[var(--neumorphic-text-secondary)] mt-1">
                                    <span title="IP Address">IP: ${urlData.ip || '--'}</span> |
                                    <span title="Response Time">Resp: ${responseTimeText}</span> |
                                    <span title="Uptime (Last ${Math.round(HISTORY_DURATION_MS / 60000)} min)">Up: ${uptimePercentage}</span>
                                </p>
                                <p class="text-xs text-[var(--neumorphic-text-placeholder)] mt-0.5">${lastCheckedText}</p>
                            </div>
                        </div>
                         <!-- Smaller, round remove button -->
                        <button class="removeUrlBtn flex-shrink-0 w-7 h-7 flex items-center justify-center rounded-full neumorphic-shadow-outer-sm neumorphic-button text-[var(--neumorphic-text-secondary)] hover:text-[var(--neumorphic-error)] transition-colors mt-1" title="Stop Monitoring">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4">
                              <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                    ${historyBarHtml}
                `;

                const removeButton = item.querySelector('.removeUrlBtn');
                if (removeButton) {
                   removeButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent potential card click events
                        removeUrl(urlData.id);
                   });
                }
                 listContainer.appendChild(item);
            });
        }


        // --- Event Handlers & Logic ---
        async function addUrl() {
            let urlValue = urlInput.value.trim();
            errorMsg.textContent = '';

            if (!urlValue) {
                // No error message, just don't add
                return;
            }

            if (!urlValue.startsWith('http://') && !urlValue.startsWith('https://')) {
                urlValue = 'https://' + urlValue;
            }

            try {
                new URL(urlValue);
            } catch (_) {
                errorMsg.textContent = 'Invalid URL format.';
                return;
            }

            const normalizedUrl = urlValue.replace(/\/+$/, '').toLowerCase();
             if (monitoredUrls.some(url => url.url.replace(/\/+$/, '').toLowerCase() === normalizedUrl)) {
                 errorMsg.textContent = 'URL already monitored.';
                 return;
            }

            addUrlBtn.disabled = true;
            addUrlBtn.innerHTML = `<span class="loader !border-t-[var(--neumorphic-accent)] !w-4 !h-4 !border-2 !mt-0"></span>`; // Show loader in button
            urlInput.disabled = true;

            let ip = 'N/A';
             try {
                 const hostname = new URL(urlValue).hostname;
                 if (hostname && hostname !== 'localhost' && !/^\d{1,3}(\.\d{1,3}){3}$/.test(hostname)) { // Only lookup non-IPs
                    ip = await getIpAddress(hostname);
                 } else if (hostname) {
                     ip = hostname; // Use hostname if it's an IP or localhost
                 }
             } catch (e) {
                 console.error("Error parsing hostname or getting IP:", e);
             }


            const newUrlData = {
                id: nextId++,
                url: urlValue,
                status: 'pending',
                ip: ip,
                responseTime: null,
                lastChecked: null,
                intervalId: null,
                isChecking: false,
                history: []
            };

            monitoredUrls.push(newUrlData);
            saveUrlsToStorage();
            renderUrlList(); // Add to list
            startCheckingUrl(newUrlData); // Start checks

            urlInput.value = '';
            addUrlBtn.disabled = false;
            urlInput.disabled = false;
            addUrlBtn.innerHTML = 'Add';
        }

        function removeUrl(id) {
            const index = monitoredUrls.findIndex(url => url.id === id);
            if (index > -1) {
                const urlData = monitoredUrls[index];
                if (urlData.intervalId) {
                    clearInterval(urlData.intervalId);
                    urlData.intervalId = null;
                }
                monitoredUrls.splice(index, 1);
                saveUrlsToStorage();
                renderUrlList(); // Re-render the list
            }
        }

        function startCheckingUrl(urlData) {
            if (urlData.intervalId) clearInterval(urlData.intervalId);
             // Check immediately with a small random delay to stagger initial loads
             setTimeout(() => checkUrlStatus(urlData), Math.random() * 500);
            urlData.intervalId = setInterval(() => {
                checkUrlStatus(urlData);
            }, PING_INTERVAL_MS);
        }

        function startAllChecks() {
             monitoredUrls.forEach(urlData => {
                 startCheckingUrl(urlData); // Initial check happens inside startCheckingUrl now
             });
        }

        // --- Initialization ---
        addUrlBtn.addEventListener('click', addUrl);
        urlInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                 event.preventDefault();
                addUrl();
            }
        });

        document.addEventListener('DOMContentLoaded', loadUrlsFromStorage);

         window.addEventListener('beforeunload', () => {
             monitoredUrls.forEach(urlData => {
                 if (urlData.intervalId) {
                     clearInterval(urlData.intervalId);
                 }
             });
         });

    </script>
    <!-- PWA Service Worker Registration (kept from original) -->
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js') // Assumes service-worker.js is in the same directory
                .then(registration => {
                    console.log('Service Worker registered with scope:', registration.scope);
                     // Background Sync registration logic remains the same as original code
                     // ... (SyncManager, periodicSync checks)
                })
                .catch(error => {
                    console.error('Service Worker registration failed:', error);
                });
        } else {
            console.warn('Service workers are not supported in this browser.');
        }
    </script>
<!--
Notes:
1. Design: UI updated with a Neumorphic design aesthetic inspired by the provided image (light background, soft shadows, rounded corners). Uses CSS variables for easier theme adjustments.
2. History Data Persistence: Same as before - history points are session-only and not stored in localStorage.
3. Ping Method Limitations: Still uses client-side 'no-cors' fetch with the same limitations.
4. IP Lookup: Still uses client-side DoH lookup.
5. PWA/Background Sync: Service worker registration and sync logic are kept from the original code. A 'service-worker.js' and 'manifest.json' file would be needed in the same directory for PWA features to work.
6. Font: Added Google Font 'Inter' for a cleaner look, similar to modern UI designs.
-->
</body>
</html>